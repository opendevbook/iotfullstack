{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to Fullstack IoT Course","text":"<p>Welcome to the Fullstack IoT course, where you will embark on an exciting journey to become proficient in the rapidly evolving field of the Internet of Things (IoT). This course is designed to provide you with the essential skills to develop, deploy, and manage IoT applications that integrate both the hardware and software aspects of IoT systems. By the end of the course, you will have a strong understanding of how to create end-to-end solutions for IoT devices, connecting them to the cloud, and leveraging powerful data analytics and visualization tools.</p>"},{"location":"#course-overview","title":"Course Overview","text":"<p>In today's interconnected world, IoT devices are everywhere \u2013 from smart home systems to industrial machines, healthcare devices, and environmental monitoring solutions. Fullstack IoT development involves understanding both the frontend (user interfaces, data visualization) and the backend (device management, cloud communication, data storage) of an IoT system. This course will equip you with the tools and technologies needed to design, implement, and scale IoT systems that are secure, reliable, and efficient.</p> <p>The course will cover the following major areas:</p>"},{"location":"#1-iot-architecture-and-protocols","title":"1. IoT Architecture and Protocols","text":"<p>You will learn about the fundamental components of an IoT system, including sensors, devices, networks, and cloud infrastructure. You will also gain hands-on experience with IoT communication protocols such as MQTT, CoAP, HTTP, and more.</p>"},{"location":"#2-embedded-systems-development","title":"2. Embedded Systems Development","text":"<p>Understanding the core hardware is crucial in IoT. You will explore microcontroller programming (e.g., Arduino, ESP32, Raspberry Pi) to interact with sensors, relays, actuators, and other hardware components. You will also learn about the principles of device management and firmware development.</p>"},{"location":"#3-cloud-integration-and-data-management","title":"3. Cloud Integration and Data Management","text":"<p>A critical part of any IoT system is cloud connectivity. In this course, you will learn how to connect IoT devices to cloud platforms (e.g., ThingsBoard, AWS IoT, Azure IoT) and perform tasks like device monitoring, real-time data collection, and remote control. You will also explore the storage, processing, and analysis of IoT data using databases and big data tools.</p>"},{"location":"#4-frontend-development-for-iot-applications","title":"4. Frontend Development for IoT Applications","text":"<p>The user interface is essential for interacting with IoT systems. You will gain skills in web and mobile frontend development using frameworks such as React, Vue.js, or Angular. You'll design dashboards and visualize real-time data from IoT devices, making it easier for users to monitor and control their devices.</p>"},{"location":"#5-security-and-privacy-in-iot","title":"5. Security and Privacy in IoT","text":"<p>As IoT devices become increasingly integrated into everyday life, security becomes a top priority. You will learn best practices for securing IoT networks, encrypting communications, and protecting sensitive data both at rest and in transit.</p>"},{"location":"#6-end-to-end-project","title":"6. End-to-End Project","text":"<p>You will apply your knowledge by building an end-to-end IoT solution that includes both hardware and software components. This could involve creating a smart home system, industrial monitoring solution, environmental sensor network, or healthcare device, depending on your interests.</p>"},{"location":"#learning-outcomes","title":"Learning Outcomes","text":"<p>Upon successful completion of this course, you will be able to:</p> <ul> <li>Understand and apply IoT protocols and communication methods for device-to-cloud and cloud-to-device communication.</li> <li>Program and interface with IoT hardware, including sensors, actuators, and embedded systems.</li> <li>Develop secure and scalable cloud applications for IoT systems.</li> <li>Design interactive, user-friendly dashboards and mobile applications to manage IoT devices and data.</li> <li>Implement real-time data processing and analytics to derive meaningful insights from IoT systems.</li> <li>Address security and privacy concerns in IoT solutions and apply best practices in protecting devices and data.</li> </ul>"},{"location":"#why-take-this-course","title":"Why Take This Course?","text":"<ul> <li>Hands-On Experience: This course offers a hands-on approach where you will build real IoT projects that demonstrate your skills in both the hardware and software aspects.</li> <li>In-Demand Skills: IoT is transforming industries globally, and full-stack IoT developers are in high demand. This course prepares you for a career in IoT development, embedded systems, and cloud computing.</li> <li>Interdisciplinary Learning: This course integrates knowledge from electronics, programming, networking, data analytics, and cloud computing, giving you a broad skill set that is essential for the future of technology.</li> </ul> <p>By the end of the course, you will have a well-rounded understanding of fullstack IoT development and be prepared to build innovative IoT solutions that connect devices, collect data, and provide actionable insights across various domains such as smart cities, healthcare, agriculture, and manufacturing.</p> <p>We look forward to guiding you through this exciting and dynamic course in Fullstack IoT development!</p> <p>Best regards,  Sawangpong muadphet CTO, Founder Komomi</p>"},{"location":"iotplatform/","title":"IoT platform on Cloud and on Premise","text":""},{"location":"iotplatform/#overview-thingsbaord","title":"Overview thingsbaord","text":"<ul> <li>Devices represent the range of various types of IoT devices which can be connected to ThingsBoard such as, thermostats, sensors, gps trackers, etc.</li> <li>ThingsBoard Transport microservices is the collection of transport servers which responsible for transporting the data from the IoT device to the ThingsBoard Core. This includes the HTTP 2, MQTT 3 and CoAP 4 servers.</li> <li>ThingsBoard Core microservices consists of core node(s) responsible for handling REST API calls, websocket subscriptions, process messages from devices via Rule Engine and monitor connectivity state of the devices.</li> <li>ThingsBoard Rule Engine microservices include configurable chain of rules that are used to process incoming messages from the devices. They also include JavaScript Executor Microservices which allows users to add custom JavaScript functions to process incoming data.</li> <li>ThingsBoard Web UI allows users to interact with the system by letting them visualize the devices data and configure the rule engine.</li> <li>Things-Party systems entails databases (Cassandra, PostgreSQL), queuing software (Apache Kafka), data structure storage for caching (Redis) and distribution coordination servers (ZooKeeper).5 A more in-depth analysis of these components can be found in one of our previous essays titled \u2018ThingsBoard - Architecture\u2019.6</li> </ul>"},{"location":"iotplatform/#understand-mqtt-protocol","title":"Understand MQTT protocol","text":"<p>MQTT (Message Queuing Telemetry Transport) is a lightweight messaging protocol widely used in IoT (Internet of Things) for efficient communication between devices, especially in scenarios with limited bandwidth or unstable networks. Designed for high latency and low bandwidth environments, MQTT enables fast, reliable, and real-time data exchange between IoT devices, such as sensors, actuators, and control systems, with a centralized broker that manages message distribution.</p> <p>The Thingsboard server system functions as a MQTT broker and provides support for QoS levels 0 and 1</p> <p></p> <p>Key Concepts in MQTT for IoT:</p> <p>1 Broker-Based Model: MQTT uses a publish-subscribe model facilitated by a broker (such as Mosquitto or HiveMQ). IoT devices (clients) publish messages to specific topics, and other devices or systems subscribe to these topics to receive the data. This structure reduces direct device-to-device connections and centralizes data management.</p> <p>2 Topics and Messages: Topics are hierarchical labels that organize data streams (e.g., sensor/temperature/room1). Devices publish messages to topics, and subscribers receive messages for topics they are interested in, allowing fine-grained control of data flows.</p> <p>3 Quality of Service (QoS): MQTT offers three QoS levels:</p> <ul> <li>QoS 0: \"At most once\" \u2013 message delivery is not guaranteed.</li> <li>QoS 1: \"At least once\" \u2013 message delivery is guaranteed but may be duplicated.</li> <li>QoS 2: \"Exactly once\" \u2013 message delivery is assured only once.</li> </ul> <p>4 Lightweight Protocol: MQTT has minimal packet headers and supports small data payloads, making it suitable for resource-constrained devices and networks.</p> <p>5 Retained Messages: MQTT allows the last message published to a topic to be retained, so new subscribers receive the most recent state data immediately upon subscribing.</p> <p>6 Last Will and Testament (LWT): This feature allows devices to define a message sent by the broker if they unexpectedly disconnect, enabling reliable monitoring of device health.</p> <p>Thingsboard integration diagram: </p> <p>Topic 1 Getting Started on ThingsBoard</p> <pre><code>- Introduction to ThingsBoard\n- Installing ThingsBoard on Local Servers\n- Sign Up ThingsBoard Cloud\n- ThingsBoard Use Cases\n</code></pre> <p>Topic 2 Connect Devices to ThingsBoard</p> <pre><code>- Entities &amp; Assets\n- Connect Devices to ThingsBoard\n- Upload Telemetry Data\n</code></pre> <p>Topic 3 Send Data via MQTT and HTTP</p> <pre><code>- Overview of MQTT\n- Send Data via ThingsBoard MQTT and Node-Red\n- Overview of REST HTTP\n- Send Data via ThingsBoard HTTP and Node-Red\n- Install Thingsboard library in Arduino IDE\n- Send Data via Arduino IDE\n</code></pre> <p>Topic 4 Data Visualization</p> <pre><code>- Dashboard\n- Widgets\n- Display Telemetry Data on Dashboard\n</code></pre> <p>Topic 5 Setup Rules and Triggers</p> <pre><code>- Setup Rule Chain\n- Setup Alarm Trigger\n</code></pre>"},{"location":"iotsensor/","title":"Understand Sensor Data improvement","text":""},{"location":"iotsensor/#1-use-case-collecting-and-averaging-sensor-readings","title":"1 Use Case: Collecting and Averaging Sensor Readings","text":"<p>Suppose you have a temperature sensor connected to your Arduino. You want to take a series of readings, store them, and calculate the average whenever a new reading comes in. Using std::vector allows you to easily add, remove, or analyze readings without needing to resize a fixed-size array.</p> <p>Note</p> <p>Filer data before save data to variable</p> <p>Example: muict_senser_average</p> <pre><code>#include &lt;Arduino.h&gt;\n#include &lt;vector&gt;     //#include &lt;ArduinoSTL.h&gt; in arduino compatible\n\nconst int SENSOR_PIN = A0;   // Analog pin for reading sensor data\nstd::vector&lt;float&gt; readings; // Vector to store sensor readings\n\nvoid setup() {\n    Serial.begin(9600);\n}\n\nvoid loop() {\n    // Simulate reading from a sensor (e.g., temperature)\n    float temp = analogRead(SENSOR_PIN) * (5.0 / 1023.0); // Convert analog reading to voltage\n\n    // Add the reading to the vector\n    readings.push_back(temp);\n\n    // If the vector has more than 10 readings, remove the oldest one\n    if (readings.size() &gt; 10) {\n        readings.erase(readings.begin());\n    }\n\n    // Calculate the average of the readings\n    float sum = 0;\n    for (float value : readings) {\n        sum += value;\n    }\n    float average = sum / readings.size();\n\n    // Print the current temperature and average\n    Serial.print(\"Current Reading: \");\n    Serial.print(temp);\n    Serial.print(\" V, Average: \");\n    Serial.print(average);\n    Serial.println(\" V\");\n\n    delay(1000); // Wait 1 second before next reading\n}\n</code></pre> <p></p>"},{"location":"iotsensor/#what-is-mean-filter-and-median-filter","title":"What is Mean filter and median filter","text":"<p>Mean filtering and median filtering are two related but distinct techniques often used in IoT for smoothing or processing sensor data to reduce noise:</p> <p>1 Mean Filtering (Moving Average Filter):</p> <p>Mean filtering is a type of moving average filter where you smooth out data by calculating the average of the most recent N readings. It\u2019s especially effective at reducing random noise and is easy to compute. For example, if you\u2019re measuring temperature and have readings [22.1, 21.8, 22.5, 22.3], a mean filter would calculate the average, yielding a smoothed-out value (e.g., 22.175). This filter can lag behind rapid changes in data but is excellent for reducing small fluctuations.</p> <p>2 Median Filtering (Median Smoothing):</p> <ul> <li>Median filtering is a nonlinear technique that\u2019s effective for removing outliers or spikes in data, as it\u2019s less influenced by extreme values.</li> <li>With this method, you sort your recent N readings and take the middle value (the median). For instance, with readings [22.1, 21.8, 50.5, 22.5, 22.3], sorting gives [21.8, 22.1, 22.3, 22.5, 50.5], and the median is 22.3.</li> <li>This is particularly helpful in IoT when sensors occasionally produce extreme readings due to interference or sudden, inaccurate spikes.</li> </ul> <p>3 Comparison:</p> <ul> <li>Mean filter: Smooths gradual changes well but doesn\u2019t handle sudden outliers effectively.   Median filter: Better at removing spikes, making it suitable for applications where sensor readings can be erratic.</li> </ul> <p>4 Application in IoT:</p> <ul> <li>Mean filtering: Often used for data with consistent noise patterns, such as smoothing temperature, humidity, or environmental data.</li> <li>Median filtering: Useful when data might be corrupted by sudden spikes, such as heart rate monitoring or motion detection, where abrupt false readings occur.</li> </ul>"},{"location":"iotsensor/#summary-filter-for-iot","title":"Summary Filter for IoT","text":"<ul> <li>Mean filtering: Ideal for smoothing consistent, low-noise signals.</li> <li>Median filtering: Best for handling occasional extreme values in data with outliers or spikes.</li> </ul> <p>Both techniques enhance data quality, leading to more reliable IoT sensor readings and decisions. In practical IoT applications, the choice between mean and median filtering depends on your specific data characteristics and the nature of the noise or outliers you expect to encounter.</p> <p></p> <p>Example Code: Combining Median Filter, Mean Filter, and 5-Window Convolution</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nconst int SENSOR_PIN = A0;  // Analog pin for reading sensor data\nconst int WINDOW_SIZE = 5;  // 5-window period\nstd::vector&lt;float&gt; readings;  // Vector to store sensor readings\nstd::vector&lt;float&gt; weightedReadings;  // To store weighted readings for convolution\n\n// Delay\nconst float wait_time = 200;  // 0.2 second wait time\n\n// Function to calculate the median of a vector\nfloat median(std::vector&lt;float&gt; &amp;data) {\n    std::sort(data.begin(), data.end());\n    int size = data.size();\n    if (size % 2 == 0) {\n        return (data[size / 2 - 1] + data[size / 2]) / 2.0;\n    } else {\n        return data[size / 2];\n    }\n}\n\n// Function to calculate the moving average (mean filter)\nfloat mean(std::vector&lt;float&gt; &amp;data) {\n    float sum = 0;\n    for (float val : data) {\n        sum += val;\n    }\n    return sum / data.size();\n}\n\n\nvoid setup() {\n    Serial.begin(9600);\n}\n\nvoid loop() {\n    // Simulate reading from a sensor\n    float sensorValue = analogRead(SENSOR_PIN) * (5.0 / 1023.0);  // Convert analog reading to voltage\n    readings.push_back(sensorValue);  // Store sensor value in readings\n\n    // Ensure the size of the readings vector does not exceed WINDOW_SIZE\n    if (readings.size() &gt; WINDOW_SIZE) {\n        readings.erase(readings.begin());\n    }\n\n    // Apply Median Filter\n    std::vector&lt;float&gt; filteredReadings = readings;  // Copy to apply median\n    float medianFiltered = median(filteredReadings);\n\n    // Apply Mean Filter on the filtered data\n    float meanFiltered = mean(filteredReadings);\n\n    // Print results\n    Serial.print(\"Raw Sensor Value: \");\n    Serial.print(sensorValue);\n    Serial.print(\" V, \");\n    Serial.print(\"Median Filtered Value: \");\n    Serial.print(medianFiltered);\n    Serial.print(\" V, \");\n    Serial.print(\"Mean Filtered Value: \");\n    Serial.print(meanFiltered);\n    Serial.print(\" V, \");\n\n\n    // Wait for 0.2 seconds before next reading\n    delay(wait_time);\n}\n</code></pre>"},{"location":"iotsensor/#use-convoltion-technic","title":"Use Convoltion Technic","text":"<p>To combine Median Filtering, Average Filtering (Mean), and a Convolution with a 5-window period while introducing a 0.2-second delay between each calculation in an IoT application, you need to structure your filter logic accordingly.</p> <p>Here's how you can approach this:</p> <p>1 Median Filtering: This will help remove outliers (spikes). 2 Mean Filtering: This will smooth out the overall signal by averaging. 3 Convolution with 5 Window Period: This is used to apply a weighted average across a moving window. 4 0.2-second Wait: This will allow the system to take readings at intervals. Steps: 1 Median Filter: Apply the median filter to remove spikes. 2 Mean Filter: After the median, calculate the moving average (mean). 3 5-Window Convolution: Implement a convolution that processes the average of 5 recent readings, applying weights if necessary.</p> <p>Wait: Add a 0.2-second delay between readings.</p> <p></p> <p>Example: muict_sensor_convolute.ino</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nconst int SENSOR_PIN = A0;  // Analog pin for reading sensor data\nconst int WINDOW_SIZE = 5;  // 5-window period\nstd::vector&lt;float&gt; readings;  // Vector to store sensor readings\nstd::vector&lt;float&gt; weightedReadings;  // To store weighted readings for convolution\n\n// Delay\nconst float wait_time = 200;  // 0.2 second wait time\n\n// Function to calculate the median of a vector\nfloat median(std::vector&lt;float&gt; &amp;data) {\n    std::sort(data.begin(), data.end());\n    int size = data.size();\n    if (size % 2 == 0) {\n        return (data[size / 2 - 1] + data[size / 2]) / 2.0;\n    } else {\n        return data[size / 2];\n    }\n}\n\n// Function to calculate the moving average (mean filter)\nfloat mean(std::vector&lt;float&gt; &amp;data) {\n    float sum = 0;\n    for (float val : data) {\n        sum += val;\n    }\n    return sum / data.size();\n}\n\n// Function for 5-window convolution (simple moving average filter)\nfloat convolution1(std::vector&lt;float&gt; &amp;data) {\n    // Simple moving average convolution with weights (equal weights)\n    float sum = 0;\n    for (float val : data) {\n        sum += val;  // Equal weighting\n    }\n    return sum / data.size();  // Return the average over the window\n}\n\nfloat convolution2(std::vector&lt;float&gt; &amp;data) {\n    // Weighted moving average (example: more weight on the middle)\n    float weights[] = {0.1, 0.2, 0.3, 0.2, 0.1};\n    float sum = 0;\n    for (int i = 0; i &lt; data.size(); i++) {\n        sum += data[i] * weights[i];  // Apply weight to each element\n    }\n    return sum;  // Return weighted sum\n}\n\nvoid setup() {\n    Serial.begin(9600);\n}\n\nvoid loop() {\n    // Simulate reading from a sensor\n    float sensorValue = analogRead(SENSOR_PIN) * (5.0 / 1023.0);  // Convert analog reading to voltage\n    readings.push_back(sensorValue);  // Store sensor value in readings\n\n    // Ensure the size of the readings vector does not exceed WINDOW_SIZE\n    if (readings.size() &gt; WINDOW_SIZE) {\n        readings.erase(readings.begin());\n    }\n\n    // Apply Median Filter\n    std::vector&lt;float&gt; filteredReadings = readings;  // Copy to apply median\n    float medianFiltered = median(filteredReadings);\n\n    // Apply Mean Filter on the filtered data\n    float meanFiltered = mean(filteredReadings);\n\n    // Apply Convolution Filter (5-window period)\n    // Try function  convolution2\n    float convolutionFiltered = convolution1(filteredReadings);\n\n    // Print results\n    Serial.print(\"Raw Sensor Value: \");\n    Serial.print(sensorValue);\n    Serial.print(\" V, \");\n    Serial.print(\"Median Filtered Value: \");\n    Serial.print(medianFiltered);\n    Serial.print(\" V, \");\n    Serial.print(\"Mean Filtered Value: \");\n    Serial.print(meanFiltered);\n    Serial.print(\" V, \");\n    Serial.print(\"Convolution Filtered Value: \");\n    Serial.print(convolutionFiltered);\n    Serial.println(\" V\");\n\n    // Wait for 0.2 seconds before next reading\n    delay(wait_time);\n}\n</code></pre>"},{"location":"iotsensor/#customize-and-understand-weigted","title":"Customize and understand weigted","text":"<p>Note</p> <p>Custom weight</p> <p>This is an example of a 5-point weighted moving average. Let\u2019s break down why these specific weights might be chosen:</p> <p>part1 0.1 at the ends (weights[0] and weights[4]):</p> <ul> <li>The outermost values (older values in the window) get the smallest weight because they are assumed to be less relevant for predicting or smoothing the current trend. The older data might not reflect current sensor conditions as closely as the more recent data.</li> </ul> <p>part2 0.2 for the second and fourth values (weights[1] and weights[3]):</p> <ul> <li>These are the next most recent data points, and they are still important, but slightly less so than the center. By giving them a weight of 0.2, we give them more importance than the older readings, but less than the most recent one.</li> </ul> <p>part3 0.3 at the center (weights[2]):</p> <ul> <li>The central value (the third element in the window) is considered the most important since it represents the most recent reading in the dataset. This value is given the highest weight (0.3) because it is assumed to be the most relevant for understanding the current state of the system.</li> </ul>"},{"location":"iotstack/","title":"Full Stack IoT Development","text":""},{"location":"iotstack/#iot-development-landscape","title":"IoT Development landscape","text":""},{"location":"iotstack/#handling-sensor-data-in-iot","title":"Handling Sensor Data in IoT","text":"<p>Effectively managing sensor data in IoT applications is essential for making informed decisions, optimizing performance, and ensuring data reliability. This guide covers key approaches and techniques for handling sensor data in IoT.</p>"},{"location":"iotstack/#1-data-collection-and-sampling","title":"1. Data Collection and Sampling","text":"<ul> <li>Sampling Frequency: Choose an appropriate sampling rate based on sensor type and application needs. Higher frequencies capture more detail but consume more resources; lower frequencies save power but may miss rapid changes.</li> <li>Data Preprocessing: Apply basic processing to clean up raw data, which can include removing outliers or applying filters.</li> </ul>"},{"location":"iotstack/#2-data-filtering-techniques","title":"2. Data Filtering Techniques","text":"<ul> <li>Noise Reduction: Sensors often produce noisy data due to environmental factors. Use filters to smooth data:</li> <li>Moving Average Filter: Averages a window of data points to smooth out fluctuations.</li> <li>Median Filter: Sorts data in a window and selects the median, effectively removing outliers without blurring sharp changes.</li> <li>Weighted Moving Average: Uses a weighted sum, giving more importance to recent data to balance noise reduction with sensitivity.</li> <li>Mean Filtering: Similar to averaging but may incorporate additional statistical measures to further refine data quality.</li> </ul>"},{"location":"iotstack/#3-data-compression-and-reduction","title":"3. Data Compression and Reduction","text":"<ul> <li>Event-Driven Sampling: Collect and transmit data only when conditions or thresholds are met, reducing data volume.</li> <li>Aggregation: Average, sum, or combine data from multiple sources or over a period to reduce the amount of data without losing key information.</li> <li>Delta Encoding: Send only the change in data since the last transmission, useful for slow-changing metrics.</li> </ul>"},{"location":"iotstack/#4-data-storage-and-organization","title":"4. Data Storage and Organization","text":"<ul> <li>Time Series Databases: Use specialized databases like InfluxDB or TimescaleDB for storing time-stamped data.</li> <li>Edge Storage: Store recent data locally on the device or an edge server to handle intermittent connectivity issues or enable local processing.</li> </ul>"},{"location":"iotstack/#5-data-transmission-protocols","title":"5. Data Transmission Protocols","text":"<ul> <li>MQTT: A lightweight, publish-subscribe protocol suitable for IoT due to low bandwidth usage and efficient message handling.</li> <li>HTTP/HTTPS: Useful for web-based IoT applications but more resource-intensive than MQTT.</li> <li>CoAP (Constrained Application Protocol): Optimized for low-power devices, using less bandwidth and power than HTTP.</li> </ul>"},{"location":"iotstack/#6-data-processing-and-analysis","title":"6. Data Processing and Analysis","text":"<ul> <li>Real-Time Processing: Analyze data as it arrives for immediate insights, such as anomaly detection.</li> <li>Batch Processing: Process data in batches at scheduled intervals for resource-intensive analysis like pattern recognition.</li> <li>Machine Learning Models: Deploy ML models for advanced analysis, such as predictive maintenance, anomaly detection, or trend prediction.</li> </ul>"},{"location":"iotstack/#7-security-and-privacy","title":"7. Security and Privacy","text":"<ul> <li>Data Encryption: Encrypt data both in transit and at rest to protect sensitive information.</li> <li>Access Control: Limit access to sensor data to authorized users and systems.</li> <li>Anonymization: Anonymize data to protect user privacy, especially for applications handling personal or location data.</li> </ul>"},{"location":"iotstack/#8-data-visualization-and-insights","title":"8. Data Visualization and Insights","text":"<ul> <li>Dashboards: Use platforms like Grafana or ThingsBoard to visualize sensor data in real-time for easy monitoring.</li> <li>Alerts and Notifications: Set up alerts for threshold breaches or unusual patterns in data to enable timely responses to critical events.</li> </ul>"},{"location":"iotstack/#summary","title":"Summary","text":"<p>Handling IoT sensor data effectively involves careful planning across data collection, filtering, compression, transmission, processing, and security. By choosing appropriate techniques for each stage, you can ensure high data quality, efficient resource usage, and valuable insights from sensor networks.</p>"},{"location":"Day1%20%3A%20Workshop/1mqttintro/","title":"1 Summary Thingsboard Topic","text":"<p>In ThingsBoard, MQTT topics allow devices to communicate by publishing telemetry data, receiving RPC commands, and updating shared attributes. When using an ESP32 with ThingsBoard over MQTT, the main topics typically include:</p>"},{"location":"Day1%20%3A%20Workshop/1mqttintro/#connct-mqtt-in-thingsboard","title":"Connct MQTT in thingsboard","text":"<p>We will use access token device credentials in this article and they will be referred to later as $ACCESS_TOKEN. The application needs to send MQTT CONNECT message with username that contains $ACCESS_TOKEN. Possible return codes and their reasons during connect sequence:</p> <pre><code>0x00 Connected - Successfully connected to ThingsBoard MQTT server.\n\n0x04 Connection Refused, bad user name or password - Username is empty.\n\n0x05 Connection Refused, not authorized - Username contains invalid $ACCESS_TOKEN.\n</code></pre>"},{"location":"Day1%20%3A%20Workshop/1mqttintro/#what-is-data-json-format","title":"What is data json format?","text":"<p>Key-value format\uf0c1</p> <p>By default, ThingsBoard supports key-value content in JSON. Key is always a string, while value can be either string, boolean, double, long or JSON. For example:</p> <pre><code>{\n  \"stringKey\": \"value1\",\n  \"booleanKey\": true,\n  \"doubleKey\": 42.0,\n  \"longKey\": 73,\n  \"jsonKey\": {\n    \"someNumber\": 42,\n    \"someArray\": [1, 2, 3],\n    \"someNestedObject\": { \"key\": \"value\" }\n  }\n}\n</code></pre>"},{"location":"Day1%20%3A%20Workshop/1mqttintro/#mqtt-topic-pettern","title":"MQTT Topic pettern","text":"<p>In MQTT, Topic refers to a UTF-8 string that filters messages for a connected client. A topic consists of one or more levels separated by a forward slash (topic level separator)</p> <p></p>"},{"location":"Day1%20%3A%20Workshop/1mqttintro/#mqtt-wildcards-single-level-multi-level","title":"MQTT WildCards single-level , multi-level","text":"<p>The single-level wildcard is represented by the plus symbol (+) and allows the replacement of a single topic level. By subscribing to a topic with a single-level wildcard, any topic that contains an arbitrary string in place of the wildcard will be matched.</p> <p></p> <p>Single Level: myhome/groundfloor/+/temperature</p> <p></p> <p>Multi Level:</p> <p></p> <p>it receives all messages of a topic that begins with the pattern before the wildcard character, regardless of the length or depth of the topic.</p> <p></p>"},{"location":"Day1%20%3A%20Workshop/1mqttintro/#welcome-to-iot-mqtt-topic-in-thingsboard","title":"Welcome to IoT mqtt topic in Thingsboard","text":"<p>1 Telemetry Data Topic:</p> <pre><code>Topic: v1/devices/me/telemetry\n</code></pre> <p>Purpose: ESP32 devices publish sensor readings or state information as telemetry data here. This data can include temperature, humidity, or custom metrics that ThingsBoard will visualize or process further.</p> <p></p> <p>2 Attributes:</p> <pre><code>Topic (Client-side Attributes): v1/devices/me/attributes\n</code></pre> <p>Purpose: ESP32 can publish its static or dynamic attributes, like device location, firmware version, or any state configuration, to ThingsBoard. This helps keep ThingsBoard updated with device-specific info.</p> <p></p> <p></p> <pre><code>Topic (Shared Attributes): v1/devices/me/attributes/request\n</code></pre> <p>Purpose: ESP32 can request shared attributes that ThingsBoard has defined, which can include configuration settings. These are useful when the device needs configuration data set from ThingsBoard's dashboard.</p> <p></p> <p>3 RPC Commands:</p> <pre><code>Topic (RPC Request): v1/devices/me/rpc/request/{requestId}\n</code></pre> <p>Purpose: ESP32 can receive remote commands from ThingsBoard, allowing control actions (like turning on a relay) triggered from the ThingsBoard dashboard. Each RPC request has a unique requestId to track responses.</p> <pre><code>Topic (RPC Response): v1/devices/me/rpc/response/{requestId}\n</code></pre> <p>Purpose: ESP32 uses this to respond back with success or status information once an RPC command is completed.</p> <p></p> <p>Example code: muict_lab1.ino</p> <pre><code>#include &lt;WiFi.h&gt;\n#include &lt;PubSubClient.h&gt;\n\nconst char* ssid = \"YOUR_WIFI_SSID\";\nconst char* password = \"YOUR_WIFI_PASSWORD\";\nconst char* mqtt_server = \"YOUR_THINGSBOARD_SERVER_IP\";\nconst char* access_token = \"YOUR_DEVICE_ACCESS_TOKEN\"; // Access token for your ThingsBoard device\n\nWiFiClient espClient;\nPubSubClient client(espClient);\n\n// Callback function for incoming MQTT messages (like RPC commands)\nvoid callback(char* topic, byte* payload, unsigned int length) {\n    Serial.print(\"Message arrived on topic: \");\n    Serial.println(topic);\n    // Handle specific topic messages here\n}\n\n// Connect to WiFi\nvoid setup_wifi() {\n    delay(10);\n    Serial.println(\"Connecting to WiFi...\");\n    WiFi.begin(ssid, password);\n\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n    }\n    Serial.println(\"WiFi connected\");\n}\n\n// Reconnect to MQTT broker if disconnected\nvoid reconnect() {\n    while (!client.connected()) {\n        Serial.print(\"Connecting to MQTT broker...\");\n        if (client.connect(\"ESP32Client\", access_token, NULL)) {\n            Serial.println(\"Connected\");\n            client.subscribe(\"v1/devices/me/rpc/request/+\"); // Subscribe to RPC commands\n        } else {\n            Serial.print(\"Failed, rc=\");\n            Serial.print(client.state());\n            Serial.println(\" try again in 5 seconds\");\n            delay(5000);\n        }\n    }\n}\n\n// Initialize MQTT client and set callback\nvoid setup_mqtt() {\n    client.setServer(mqtt_server, 1883);\n    client.setCallback(callback);\n}\n\n// Publish telemetry data to ThingsBoard\nvoid publishTelemetry(const char* data) {\n    if (client.connected()) {\n        client.publish(\"v1/devices/me/telemetry\", data);\n        Serial.println(\"Telemetry published\");\n    } else {\n        Serial.println(\"Failed to publish telemetry\");\n    }\n}\n\n// Publish attributes to ThingsBoard\nvoid publishAttributes(const char* attributes) {\n    if (client.connected()) {\n        client.publish(\"v1/devices/me/attributes\", attributes);\n        Serial.println(\"Attributes published\");\n    } else {\n        Serial.println(\"Failed to publish attributes\");\n    }\n}\n\n// Request shared attributes from ThingsBoard\nvoid requestSharedAttributes() {\n    if (client.connected()) {\n        client.publish(\"v1/devices/me/attributes/request/1\", \"{\\\"sharedKeys\\\":\\\"deviceState1,deviceState2\\\"}\");\n        Serial.println(\"Requested shared attributes\");\n    } else {\n        Serial.println(\"Failed to request shared attributes\");\n    }\n}\n\n// Respond to RPC command\nvoid sendRPCResponse(const char* requestId, const char* response) {\n    String topic = \"v1/devices/me/rpc/response/\";\n    topic += requestId; // Construct topic with requestId\n    if (client.connected()) {\n        client.publish(topic.c_str(), response);\n        Serial.print(\"RPC response sent: \");\n        Serial.println(response);\n    } else {\n        Serial.println(\"Failed to send RPC response\");\n    }\n}\n\n// Example RPC command handler\nvoid handleRPCCommand(byte* payload, unsigned int length) {\n    // Convert payload to string\n    String command;\n    for (unsigned int i = 0; i &lt; length; i++) {\n        command += (char)payload[i];\n    }\n    Serial.print(\"RPC command received: \");\n    Serial.println(command);\n\n    // Example action (toggle a relay or send response)\n    // In actual code, parse command and execute specific actions\n    if (command == \"{\\\"method\\\":\\\"toggleRelay\\\"}\") {\n        // Here you would toggle a relay, e.g., digitalWrite(relayPin, !digitalRead(relayPin));\n        sendRPCResponse(\"1\", \"{\\\"status\\\":\\\"Relay toggled\\\"}\");\n    }\n}\n\n// Main setup function\nvoid setup() {\n    Serial.begin(115200);\n    setup_wifi(); // Connect to WiFi\n    setup_mqtt(); // Initialize MQTT client\n}\n\n// Main loop function\nvoid loop() {\n    if (!client.connected()) {\n        reconnect(); // Reconnect if MQTT is disconnected\n    }\n    client.loop();\n\n    // Publish telemetry example (replace with actual sensor data)\n    publishTelemetry(\"{\\\"temperature\\\":25.5,\\\"humidity\\\":60}\");\n\n    // Request shared attributes example\n    requestSharedAttributes();\n\n    // Publish device attributes example\n    publishAttributes(\"{\\\"firmware_version\\\":\\\"1.0\\\",\\\"location\\\":\\\"Room1\\\"}\");\n\n    delay(5000); // Wait 5 seconds before next loop iteration\n}\n</code></pre>"},{"location":"Day1%20%3A%20Workshop/1thingsboard/","title":"2 Create Thingsboard Account","text":"<p>Visit https://demo.thingsboard.io/login</p> <p></p> <p>After Login with account: </p> <p>Create Device: </p> <p>Select Menu Add Device: </p> <p>Device infomation: </p> <p>Device Test Script: Linux curl </p> <p>Device Test Script: MQTT </p> <p>Copy script for curl script and mqtt protocol</p> <ul> <li>curl -v -X POST http://demo.thingsboard.io/api/v1/4KZLx8HMR4E4nVfriEQL/telemetry --header Content-Type:application/json --data \"{temperature:25}\"</li> <li>mosquitto_pub -d -q 1 -h demo.thingsboard.io -p 1883 -t v1/devices/me/telemetry -u \"4KZLx8HMR4E4nVfriEQL\" -m \"{temperature:25}\"</li> </ul> <p>UX/UI in Dashboard: Slide in menu </p> <p>Check information in slide in panel</p> <ul> <li>copy device id \"...\"</li> <li>copy access account \"...\"</li> </ul> <p>copy 2 varible put into code</p> <p>Example: muict_lab1.ino</p> <pre><code>#include &lt;WiFi.h&gt;\n#include &lt;PubSubClient.h&gt;\n\nconst char* ssid = \"your_wifi_ssid\";             // Replace with your WiFi SSID\nconst char* password = \"your_wifi_password\";     // Replace with your WiFi Password\nconst char* mqtt_server = \"your_thingsboard_ip\"; // Replace with ThingsBoard IP\nconst int mqtt_port = 1883;                      // MQTT Port for ThingsBoard\nconst char* mqtt_token = \"your_device_token\";    // Replace with ThingsBoard Device Token\nconst char* mqtt_device_id = \"your_device_id\";    // Replace with ThingsBoard Device Token\n\nWiFiClient espClient;\nPubSubClient client(espClient);\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // Connect to WiFi\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\\nWiFi connected\");\n\n  // Setup MQTT server\n  client.setServer(mqtt_server, mqtt_port);\n  client.setCallback(callback);  // required to receive attribute updates and RPCs\n\n  // Connect to MQTT and subscribe\n  connectToMQTT();\n}\n\nvoid connectToMQTT() {\n  while (!client.connected()) {\n    Serial.print(\"Connecting to ThingsBoard MQTT...\");\n    if (client.connect(mqtt_device_id, mqtt_token, \"\")) {\n      Serial.println(\"connected\");\n\n      // Subscribe to attribute updates\n      client.subscribe(\"v1/devices/me/attributes\");\n\n      // Subscribe to RPC requests\n      client.subscribe(\"v1/devices/me/rpc/request/+\");\n\n    } else {\n      Serial.print(\"failed with state \");\n      Serial.print(client.state());\n      delay(2000);\n    }\n  }\n}\n\nvoid callback(char* topic, byte* payload, unsigned int length) {\n  Serial.print(\"Message arrived [\");\n  Serial.print(topic);\n  Serial.print(\"] \");\n\n  // Copy payload to a String for easier handling\n  String message;\n  for (int i = 0; i &lt; length; i++) {\n    message += (char)payload[i];\n  }\n  Serial.println(message);\n\n  // Check if the message is an attribute update\n  if (String(topic) == \"v1/devices/me/attributes\") {\n    Serial.println(\"Received attribute update: \" + message);\n    // Process attributes (parse message as needed)\n  }\n\n  // Check if the message is an RPC request\n  if (String(topic).startsWith(\"v1/devices/me/rpc/request/\")) {\n    int requestId = String(topic).substring(26).toInt();  // Extract RPC request ID\n    Serial.println(\"Received RPC request with ID: \" + String(requestId));\n\n    // Example: parse the RPC request (assume JSON format)\n    if (message.indexOf(\"\\\"method\\\":\\\"toggleRelay\\\"\") != -1) {\n      // Process the RPC command (e.g., toggle a relay or handle a command)\n      Serial.println(\"Toggling relay based on RPC\");\n\n      // Send response back to ThingsBoard\n      String responseTopic = \"v1/devices/me/rpc/response/\" + String(requestId);\n      String responsePayload = \"{\\\"success\\\":true}\";\n      client.publish(responseTopic.c_str(), responsePayload.c_str());\n    }\n  }\n}\n\nvoid loop() {\n  if (!client.connected()) {\n    connectToMQTT();\n  }\n  client.loop();\n\n  // Publish telemetry data (temperature example)\n  float temperature = 22.5;  // Replace with actual sensor reading\n  String payload = \"{\\\"temperature\\\": \" + String(temperature) + \"}\";\n\n  if (client.publish(\"v1/devices/me/telemetry\", payload.c_str())) {\n    Serial.println(\"Telemetry sent: \" + payload);\n  } else {\n    Serial.println(\"Failed to send telemetry\");\n  }\n\n  delay(5000);  // Adjust as needed for your application\n}\n</code></pre> <ul> <li>Copy code to arduino ide: and save to muict_lab1</li> <li>Change variable:</li> <li>mqtt_server</li> <li>mqtt_token</li> <li>mqtt_device_id</li> </ul>"},{"location":"Day1%20%3A%20Workshop/1thingsboard/#test-shared-attribute-thingsboard","title":"Test shared Attribute thingsboard","text":"<p>Example: muict_lab2.ino</p> <pre><code>#include &lt;WiFi.h&gt;\n#include &lt;PubSubClient.h&gt;\n\nconst char* ssid = \"TrueGigatexFiber_uS7_2.4G\";                       // Replace with your WiFi SSID\nconst char* password = \"itbakery@9\";                                  // Replace with your WiFi Password\nconst char* mqtt_server = \"demo.thingsboard.io\";                      // Replace with ThingsBoard IP\nconst int mqtt_port = 1883;                                           // MQTT Port for ThingsBoard\nconst char* mqtt_token = \"4KZLx8HMR4E4nVfriEQL\";                      // Replace with ThingsBoard Device Token\nconst char* mqtt_device_id = \"0cc97a60-a03b-11ef-af67-a38a7671daf5\";  // Replace with ThingsBoard Device Token\n\nWiFiClient espClient;\nPubSubClient client(espClient);\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // Connect to WiFi\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\\nWiFi connected\");\n\n  // Setup MQTT server\n  client.setServer(mqtt_server, mqtt_port);\n  client.setCallback(callback);  // required to receive attribute updates and RPCs\n\n  // Connect to MQTT and subscribe\n  connectToMQTT();\n}\n\nvoid requestAllAttributes() {\n  String requestPayload = \"{}\";  // Empty payload requests all shared attributes\n  client.publish(\"v1/devices/me/attributes/request/1\", requestPayload.c_str());\n  Serial.println(\"All attributes request sent\");\n}\n\nvoid connectToMQTT() {\n  while (!client.connected()) {\n    Serial.print(\"Connecting to ThingsBoard MQTT...\");\n    if (client.connect(mqtt_device_id, mqtt_token, \"\")) {\n      Serial.println(\"connected\");\n\n      // Subscribe to attribute updates\n      client.subscribe(\"v1/devices/me/attributes\");\n\n      // Subscribe to RPC requests\n      client.subscribe(\"v1/devices/me/rpc/request/+\");\n      requestAllAttributes();\n\n    } else {\n      Serial.print(\"failed with state \");\n      Serial.print(client.state());\n      delay(2000);\n    }\n  }\n}\n\nvoid callback(char* topic, byte* payload, unsigned int length) {\n  Serial.print(\"Message arrived [\");\n  Serial.print(topic);\n  Serial.print(\"] \");\n\n  // Copy payload to a String for easier handling\n  String message;\n  for (int i = 0; i &lt; length; i++) {\n    message += (char)payload[i];\n  }\n  Serial.println(message);\n\n  // Check if the message is an attribute update\n  if (String(topic) == \"v1/devices/me/attributes\") {\n    Serial.println(\"Received attribute update: \" + message);\n    // Process attributes (parse message as needed)\n    // Here implement message\n  }\n\n  // Check if the message is an RPC request\n  if (String(topic).startsWith(\"v1/devices/me/rpc/request/\")) {\n    int requestId = String(topic).substring(26).toInt();  // Extract RPC request ID\n    Serial.println(\"Received RPC request with ID: \" + String(requestId));\n\n    // Example: parse the RPC request (assume JSON format)\n    if (message.indexOf(\"\\\"method\\\":\\\"toggleRelay\\\"\") != -1) {\n      // Process the RPC command (e.g., toggle a relay or handle a command)\n      Serial.println(\"Toggling relay based on RPC\");\n\n      // Send response back to ThingsBoard\n      String responseTopic = \"v1/devices/me/rpc/response/\" + String(requestId);\n      String responsePayload = \"{\\\"success\\\":true}\";\n      client.publish(responseTopic.c_str(), responsePayload.c_str());\n    }\n  }\n}\n\nvoid loop() {\n  if (!client.connected()) {\n    connectToMQTT();\n  }\n  client.loop();\n\n  // Publish telemetry data (temperature example)\n  float temperature = 22.5;  // Replace with actual sensor reading\n  String payload = \"{\\\"temperature\\\": \" + String(temperature) + \"}\";\n\n  if (client.publish(\"v1/devices/me/telemetry\", payload.c_str())) {\n    Serial.println(\"Telemetry sent: \" + payload);\n  } else {\n    Serial.println(\"Failed to send telemetry\");\n  }\n\n  delay(5000);  // Adjust as needed for your application\n}\n</code></pre>"},{"location":"Day1%20%3A%20Workshop/1thingsboard/#go-to-thingsbaord-dashboard","title":"Go to thingsbaord dashboard","text":"<p>Test shared attribute</p> <p>Try to change , add value in share attribute and check serial monitor</p>"},{"location":"Day1%20%3A%20Workshop/1thingsboard/#what-next-from-here","title":"What next from here","text":""},{"location":"Day1%20%3A%20Workshop/2arduinoide/","title":"3 Arduino IDE : Upload Data","text":""},{"location":"Day1%20%3A%20Workshop/2arduinoide/#lab1-arduino-upload-data","title":"Lab1: Arduino Upload data","text":"<ul> <li>Copy 4 screen from your pc and thingsboard account in Word</li> </ul> <p>1.1 Build and uplod to thingsboard</p> <p> 2.2 Check Thingsboard Dashboard in Device name \"muict_esp32\"</p> <p></p> <p>3.3 Check Attribues in Device Infomations</p> <p></p> <p>3.4 Check Telemetry Data</p> <p></p>"},{"location":"Day1%20%3A%20Workshop/2arduinoide/#lab2-cli-command-line","title":"Lab2: Cli command line","text":"<p>2.1 Command Line Authentication to get authen token To authenticate with ThingsBoard\u2019s REST API from the command line using curl, you need to use the login endpoint to get a JWT (JSON Web Token) token. Here\u2019s how to do it:</p> <pre><code>curl -X POST -H \"Content-Type: application/json\" \\\n-d '{\"username\":\"YOUR_USERNAME\",\"password\":\"YOUR_PASSWORD\"}' \\\nhttp://YOUR_THINGSBOARD_SERVER/api/auth/login\n</code></pre> <p></p> <p>2.2 Use command line to send data to thingsboard account</p> <p>https://thingsboard.io/docs/user-guide/telemetry/</p> <p></p> <p>Get access_token first from Dashboard by click [copy access token] will save in clipboard</p> <p></p> <p>1 upload data by HTTP API</p> <pre><code>$ export THINGSBOARD_HOST_NAME=demo.thingsboard.io\n$ export ACCESS_TOKEN=&lt;from device information&gt;\n$ mosquitto_pub -d -q 1 -h \"$THINGSBOARD_HOST_NAME\" -p \"1883\" -t \"v1/devices/me/telemetry\" -u \"$ACCESS_TOKEN\" -m {\"temperature\":30}\n</code></pre> <p></p> <p>after install mqtt client package, Let try it again</p> <p></p> <p></p> <p>Basic Linux Shell variable set/get</p> <ul> <li>export VARIABLE=value</li> <li>$VARIABLE  get value</li> <li>need install mosquitto_pub in linux (ubuntu/centos/) first</li> <li>$ACCESS_TOKEN - device access token.</li> </ul> <p>2 upload data by HTTP POST</p> <ul> <li>URL /api/v1/{ACCESS_TOKEN}/telemetry</li> </ul> <pre><code>echo $ACCESS_TOKEN\ncurl -v -X POST --data \"{\"temperature\":42,\"humidity\":73}\" https://demo.thingsboard.io/api/v1/$ACCESS_TOKEN/telemetry --header \"Content-Type:application/json\"\n</code></pre> <p></p> <p>Ensure that you're connecting to ThingsBoard over HTTPS, especially if the ThingsBoard instance is set to require secure connections.</p> <p>Basic curl command</p> <p>The curl command you provided is almost correct, but it has a syntax issue with the JSON payload. You should escape the quotes around the JSON payload or use single quotes around the entire JSON body.</p> <p></p> <p>if Error, here Explanation:</p> <p>if Error, here Explanation: https://thingsboard.io/docs/reference/http-api/</p> <p>3 Use mqtt client App. Example https://mqttx.app/</p> <ul> <li>Download and install application:</li> </ul> <p></p> <ul> <li>Create connection:</li> </ul> <p></p> <ul> <li>Connection Info:</li> </ul> <p></p> <ul> <li>publish Data: v1/devices/me/telemetry:</li> </ul> <p></p> <p></p> <ul> <li>Check Data again:</li> </ul> <p></p> <p>Summary</p> <p>Remember topic  \"v1/devices/me/telemetry\"  use for public data to thingsboard iot Gateway by mqtt protocol</p>"},{"location":"Day1%20%3A%20Workshop/3RPCcontrol/","title":"4 What's RPC control?","text":"<p>ThingsBoard RPC (Remote Procedure Call) control allows you to send commands from the ThingsBoard server to a device, which is especially useful for controlling connected devices. Here's how to set up and handle RPC commands on ThingsBoard and the ESP32 device.</p> <p>esp32 have to subcript on topic v1/devices/me/rpc/request/+</p> <p>what is + sign in topic</p> <ul> <li>symbol is a wildcard character used in topics to match a single level in the topic hierarchy. It allows a subscriber to listen to multiple topics with similar structures by replacing one level in the topic hierarchy with +</li> </ul> <p>For example, given these topics:</p> <p>home/livingroom/temperature home/kitchen/temperature home/bedroom/temperature</p> <p>Examples of + Usage Topic Matching:</p> <pre><code>sensors/+/humidity would match:\nsensors/livingroom/humidity\nsensors/bedroom/humidity\n</code></pre> <p>But it would not match sensors/humidity (because + requires exactly one level to match). Multi-level Matching:</p> <pre><code>sensors/+/temperature would match any temperature readings from one level below sensors/, but only if there\u2019s exactly one additional level.\n</code></pre> <p></p>"},{"location":"Day1%20%3A%20Workshop/3RPCcontrol/#lab1-send-rpc-control-from-dashboard","title":"Lab1 Send RPC control from dashboard","text":"<ul> <li> <p>Create Dashboard for esp32 device   </p> </li> <li> <p>Create Dashboard \"muict-dashboard\"   </p> </li> <li> <p>Add widget to dasboard </p> </li> <li> <p>Select Control widget   </p> </li> <li> <p>Select Single Button   </p> </li> <li> <p>Select Device muict_esp32 , add click add   </p> </li> <li> <p>Check result in arduino ide terminal   </p> </li> <li> <p>try to click swich for 2-3 times and see result   </p> </li> </ul> <p>request id will incliment by one     v1/devices/me/rpc/request/1     v1/devices/me/rpc/request/2     v1/devices/me/rpc/request/3</p>"},{"location":"Day1%20%3A%20Workshop/3RPCcontrol/#lab2-send-rpc-from-python","title":"Lab2 Send RPC from python","text":"<p>create python environment</p> <pre><code>mkdir muict-iot-lab\ncd muict-iot-lab\npython3 -m venv venv\n\nvenv\\Script\\activate    (windows)\nsource venv/bin/activate\n</code></pre> <p></p> <p>install depemdencies:</p> <pre><code>pip install requests\n</code></pre> <p>copy code and run in terminal save as \"app.py\" .</p> <pre><code>import requests\nimport json\n\n# Replace these with your ThingsBoard credentials and device information\nTHINGSBOARD_HOST = 'http://demo.thingsboard.io'  # or your own ThingsBoard server\nUSERNAME = 'your_username'                        # Your ThingsBoard username\nPASSWORD = 'your_password'                        # Your ThingsBoard password\nDEVICE_ID = 'your_device_id'                      # Device ID of the target device\n\n\n# Step 1: Get the JWT token\ndef get_jwt_token():\n    url = f\"{THINGSBOARD_HOST}/api/auth/login\"\n    headers = {\"Content-Type\": \"application/json\"}\n    payload = json.dumps({\"username\": USERNAME, \"password\": PASSWORD})\n\n    response = requests.post(url, headers=headers, data=payload)\n\n    if response.status_code == 200:\n        print(response.json()[\"token\"])\n        return response.json()[\"token\"]\n    else:\n        print(\"Failed to get JWT token:\", response.status_code, response.text)\n        return None\n\n# Step 2: Send RPC command to the device\ndef send_rpc_request(jwt_token, method, params, timeout=5000):\n    url = f\"{THINGSBOARD_HOST}/api/plugins/rpc/oneway/{DEVICE_ID}\"\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"X-Authorization\": f\"Bearer {jwt_token}\"\n    }\n\n    payload = json.dumps({\n        \"method\": method,\n        \"params\": params,\n        \"timeout\": timeout\n    })\n\n    # Debugging: print URL and payload with newlines for better readability\n    print(\"\\nSending request to URL:\")\n    print(url)\n    print(\"\\nPayload:\")\n    print(payload)\n\n    # Send the request\n    response = requests.post(url, headers=headers, data=payload)\n\n    if response.status_code == 200:\n        print(\"\\nRPC command sent successfully.\")\n        print(\"Response:\")\n        print(response.json())\n    else:\n        print(f\"\\nFailed to send RPC command: {response.status_code}\")\n        print(\"Response body:\")\n        print(response.text)  # View the response body for debugging\n\n\n# Main function to send an RPC command\ndef main():\n    jwt_token = get_jwt_token()\n    if jwt_token:\n        method = \"toggleRelay\"  # RPC method name (e.g., 'toggleRelay')\n        params = {              # Parameters to send with the RPC command\n            \"relay\": 1,\n            \"state\": True\n        }\n\n        send_rpc_request(jwt_token, method, params)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p></p> <ul> <li>Check arduino output</li> </ul> <p></p>"},{"location":"Day1%20%3A%20Workshop/4thingsboard/","title":"5 Introduct Thingsboard.h library","text":"<p>The ThingsBoard.h library provides an interface for ESP32 (or other devices) to connect to a ThingsBoard IoT platform instance, allowing for telemetry data transmission, RPC (remote procedure call) commands, and more. Here\u2019s a basic guide on how to set it up and use it:</p> <p>prerequisition: 1 Run in Platform.io</p> <p></p> <p>Example Code:</p> <pre><code>#ifdef ESP32\n#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;Arduino_MQTT_Client.h&gt;\n#include &lt;ThingsBoard.h&gt;\n#endif\n\n// Define WiFi credentials and ThingsBoard server details\nconstexpr char WIFI_SSID[] = \"YOUR_WIFI_SSID\";\nconstexpr char WIFI_PASSWORD[] = \"YOUR_WIFI_PASSWORD\";\nconstexpr char TOKEN[] = \"YOUR_DEVICE_ACCESS_TOKEN\";\nconstexpr char THINGSBOARD_SERVER[] = \"demo.thingsboard.io\";\nconstexpr uint16_t THINGSBOARD_PORT = 1883U; // Default MQTT port\n\n// Telemetry keys\nconstexpr char TEMPERATURE_KEY[] = \"temperature\";\nconstexpr char HUMIDITY_KEY[] = \"humidity\";\nconstexpr uint16_t MAX_MESSAGE_SIZE = 128U;\nconstexpr uint32_t SERIAL_DEBUG_BAUD = 115200U;\n\n// Initialize WiFi and MQTT client\nWiFiClient espClient;\nArduino_MQTT_Client mqttClient(espClient);\nThingsBoard tb(mqttClient, MAX_MESSAGE_SIZE);\n\nvoid InitWiFi()\n{\n  Serial.println(\"Connecting to AP ...\");\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"Connected to AP\");\n}\n\nbool reconnect()\n{\n  if (WiFi.status() == WL_CONNECTED)\n  {\n    return true;\n  }\n  InitWiFi();\n  return true;\n}\n\nvoid setup()\n{\n  randomSeed(analogRead(0)); // Initialize random seed\n  Serial.begin(SERIAL_DEBUG_BAUD);\n  delay(1000);\n  InitWiFi();\n}\n\nvoid loop()\n{\n  delay(1000);\n\n  if (!reconnect())\n  {\n    return;\n  }\n\n  if (!tb.connected())\n  {\n    Serial.printf(\"Connecting to: %s with token %s\\n\", THINGSBOARD_SERVER, TOKEN);\n    if (!tb.connect(THINGSBOARD_SERVER, TOKEN, THINGSBOARD_PORT))\n    {\n      Serial.println(\"Failed to connect\");\n      return;\n    }\n  }\n\n  Serial.println(\"Sending temperature data...\");\n  tb.sendTelemetryData(TEMPERATURE_KEY, random(10, 31));\n\n  Serial.println(\"Sending humidity data...\");\n  tb.sendTelemetryData(HUMIDITY_KEY, random(40, 90));\n\n  tb.loop();\n}\n</code></pre> <p>platform.ini</p> <pre><code>[env:esp32doit-devkit-v1]\nplatform = espressif32\nboard = esp32doit-devkit-v1\nframework = arduino\nlib_ldf_mode = chain+\nlib_deps =\n    Update\n    knolleary/PubSubClient @ ^2.8\n    arduino-libraries/ArduinoHttpClient @ ^0.6.1\n    bblanchon/ArduinoJson @ ^7.2.0\n    https://github.com/thingsboard/thingsboard-client-sdk.git\n    https://github.com/arduino-libraries/ArduinoMqttClient.git\n\nmonitor_speed = 115200\n</code></pre> <p></p> <p>Add chart: </p> <p>Add Line Chart: </p> <p>Add Data Source info: </p> <p>Result Data Visualization: </p>"},{"location":"Day1%20%3A%20Workshop/5sharedattribute/","title":"6 Thingsboard Shared Attribute","text":"<p>In ThingsBoard, shared attributes are configuration values or settings that are stored on the server and can be updated by both the server and the device. They are ideal for managing device configurations remotely, such as firmware version, thresholds, or operational settings. Devices can receive updates for these attributes without needing to continuously poll the server, making shared attributes efficient for IoT applications. Key Features of Shared Attributes:</p> <p>1 Server-Device Synchronization: Shared attributes are updated on the ThingsBoard server and synchronized to the device, ensuring consistency. 2 Subscription-Based Updates: Devices can subscribe to receive updates when specific shared attributes change on the server, eliminating the need for continuous polling. 3 Remote Configuration: Using shared attributes, you can remotely manage and adjust device settings or configurations in real-time.</p> <p>Implementation Summary:</p> <p>1 Subscribe to Attributes: In the device code, the device subscribes to specific shared attributes (e.g., \"fw_version\", \"fw_tag\"). 2 Callback on Update: When ThingsBoard sends an update, the device\u2019s callback function processes 3 the changes (e.g., updating the firmware version or configurations). 4 Two-Way Communication: Both the server and the device can update shared attributes, allowing flexible and responsive device management.</p> <p>This makes shared attributes a powerful tool for IoT devices that require dynamic and centralized configuration management.</p> <pre><code>#include &lt;WiFi.h&gt;\n#include &lt;Arduino_MQTT_Client.h&gt;\n#include &lt;Shared_Attribute_Update.h&gt;\n#include &lt;ThingsBoard.h&gt;\n\nconstexpr char WIFI_SSID[] = \"YOUR_WIFI_SSID\";\nconstexpr char WIFI_PASSWORD[] = \"YOUR_WIFI_PASSWORD\";\nconstexpr char TOKEN[] = \"YOUR_DEVICE_ACCESS_TOKEN\";\nconstexpr char THINGSBOARD_SERVER[] = \"demo.thingsboard.io\";\nconstexpr uint16_t THINGSBOARD_PORT = 1883U;  // Unencrypted MQTT port\n\nconstexpr uint16_t MAX_MESSAGE_SIZE = 128U;\nconstexpr uint32_t SERIAL_DEBUG_BAUD = 115200U;\nconstexpr size_t MAX_ATTRIBUTES = 6U;\n\nWiFiClient espClient;\nArduino_MQTT_Client mqttClient(espClient);\nShared_Attribute_Update&lt;1U, MAX_ATTRIBUTES&gt; shared_update;\nconst std::array&lt;IAPI_Implementation*, 1U&gt; apis = { &amp;shared_update };\nThingsBoard tb(mqttClient, MAX_MESSAGE_SIZE, Default_Max_Stack_Size, apis);\n\nbool subscribed = false;\n\nvoid InitWiFi() {\n  Serial.println(\"Connecting to WiFi...\");\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\\nConnected to WiFi\");\n}\n\nbool reconnect() {\n  if (WiFi.status() == WL_CONNECTED) {\n    return true;\n  }\n  InitWiFi();\n  return true;\n}\n\nvoid processSharedAttributeUpdate(const JsonObjectConst &amp;data) {\n  for (auto it = data.begin(); it != data.end(); ++it) {\n    Serial.print(it-&gt;key().c_str());\n    Serial.print(\": \");\n    Serial.println(it-&gt;value().as&lt;const char*&gt;());\n  }\n}\n\nvoid setup() {\n  Serial.begin(SERIAL_DEBUG_BAUD);\n  delay(1000);\n  InitWiFi();\n}\n\nvoid loop() {\n  delay(1000);\n\n  if (!reconnect()) {\n    return;\n  }\n\n  if (!tb.connected()) {\n    Serial.printf(\"Connecting to ThingsBoard: %s with token: %s\\n\", THINGSBOARD_SERVER, TOKEN);\n    if (!tb.connect(THINGSBOARD_SERVER, TOKEN, THINGSBOARD_PORT)) {\n      Serial.println(\"Failed to connect to ThingsBoard\");\n      return;\n    }\n  }\n\n  if (!subscribed) {\n    Serial.println(\"Subscribing for shared attribute updates...\");\n    constexpr std::array&lt;const char*, MAX_ATTRIBUTES&gt; SUBSCRIBED_SHARED_ATTRIBUTES = {\n      \"fw_tag\", \"fw_version\", \"fw_title\", \"fw_checksum\", \"fw_checksum_algorithm\", \"fw_size\"\n    };\n    const Shared_Attribute_Callback&lt;MAX_ATTRIBUTES&gt; callback(&amp;processSharedAttributeUpdate, SUBSCRIBED_SHARED_ATTRIBUTES);\n    if (!shared_update.Shared_Attributes_Subscribe(callback)) {\n      Serial.println(\"Failed to subscribe for shared attribute updates\");\n      return;\n    }\n\n    Serial.println(\"Subscribe done\");\n    subscribed = true;\n  }\n\n  tb.loop();\n}\n</code></pre> <p>Add attrubute to thingsboard: manual </p> <p>Try to change some value of shard attribute</p> <p></p>"},{"location":"Day2%20%3A%20Coding/ArduinoJson7/","title":"Intriduction to ArduinoJson 7","text":"<p>ArduinoJson 7 is a lightweight and efficient JSON library for Arduino and embedded C++ projects. It's designed for parsing, creating, and manipulating JSON objects while being memory-efficient, making it ideal for resource-constrained devices like ESP32, ESP8266, and Arduino boards. Key Features of ArduinoJson 7</p> <ol> <li>JSON Parsing: Decode JSON strings received from APIs, sensors, or other devices.</li> <li>JSON Serialization: Create JSON strings to send to servers or other devices.</li> <li>Memory Efficiency: Works well on devices with limited RAM.</li> <li>Static or Dynamic Memory Allocation: Gives you control over how memory is managed.</li> <li>Compatibility: Works with Arduino, ESP32, ESP8266, STM32, and other C++ platforms.</li> </ol>"},{"location":"Day2%20%3A%20Coding/ArduinoJson7/#how-arduinojson-works","title":"How ArduinoJson Works","text":"<p>ArduinoJson revolves around these core concepts:</p> <ol> <li>JsonDocument: A container to store JSON objects and arrays in memory.</li> <li>StaticJsonDocument: Uses fixed-size memory; prevents fragmentation.</li> <li>DynamicJsonDocument: Allocates memory dynamically; more flexible but risks fragmentation.</li> <li>JsonObject: Represents a JSON object with key-value pairs.</li> <li>JsonArray: Represents a JSON array with ordered values.</li> </ol>"},{"location":"Day2%20%3A%20Coding/ArduinoJson7/#parsing-a-json-string","title":"Parsing a JSON String","text":"main.cpp<pre><code>#include &lt;ArduinoJson.h&gt;\n\nconst char* json = \"{\\\"sensor\\\":\\\"temperature\\\", \\\"value\\\":23.5}\";\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // Create a JsonDocument with enough capacity\n  JsonDocument doc;\n\n  // Parse JSON string\n  DeserializationError error = deserializeJson(doc, json);\n\n  if (error) {\n    Serial.print(\"Failed to parse JSON: \");\n    Serial.println(error.f_str());\n    return;\n  }\n\n  // Access JSON values\n  const char* sensor = doc[\"sensor\"];\n  float value = doc[\"value\"];\n\n  // Print parsed values\n  Serial.println(sensor); // Output: temperature\n  Serial.println(value);  // Output: 23.5\n}\n\nvoid loop() {\n  // Your main loop code\n}\n</code></pre>"},{"location":"Day2%20%3A%20Coding/ArduinoJson7/#creating-a-json-object","title":"Creating a JSON Object","text":"main.cpp<pre><code>#include &lt;ArduinoJson.h&gt;\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // Create a JsonDocument\n  JsonDocument doc;\n\n  // Populate JSON object\n  doc[\"sensor\"] = \"temperature\";\n  doc[\"value\"] = 23.5;\n\n  // Serialize to string\n  char buffer[128];\n  serializeJson(doc, buffer);\n\n  // Print JSON string\n  Serial.println(buffer); // Output: {\"sensor\":\"temperature\",\"value\":23.5}\n}\n\nvoid loop() {\n  // Your main loop code\n}\n</code></pre>"},{"location":"Day2%20%3A%20Coding/ArduinoJson7/#complex-json-example-weather-station","title":"Complex JSON Example: Weather Station","text":"<pre><code>{\n  \"station\": {\n    \"id\": \"WS1234\",\n    \"location\": {\n      \"latitude\": 37.7749,\n      \"longitude\": -122.4194\n    }\n  },\n  \"timestamp\": \"2024-11-20T15:00:00Z\",\n  \"sensors\": {\n    \"temperature\": {\n      \"value\": 22.5,\n      \"unit\": \"C\"\n    },\n    \"humidity\": {\n      \"value\": 60,\n      \"unit\": \"%\"\n    },\n    \"wind\": {\n      \"speed\": {\n        \"value\": 5.5,\n        \"unit\": \"m/s\"\n      },\n      \"direction\": \"NW\"\n    }\n  }\n}\n</code></pre>"},{"location":"Day2%20%3A%20Coding/ArduinoJson7/#parsing-the-complex-json-with-arduinojson","title":"Parsing the Complex JSON with ArduinoJson","text":"<p>Here's how to parse and access data from the complex JSON using ArduinoJson:</p> <pre><code>#include &lt;ArduinoJson.h&gt;\n\nconst char* weatherJson = R\"({\n  \"station\": {\n    \"id\": \"WS1234\",\n    \"location\": {\n      \"latitude\": 37.7749,\n      \"longitude\": -122.4194\n    }\n  },\n  \"timestamp\": \"2024-11-20T15:00:00Z\",\n  \"sensors\": {\n    \"temperature\": {\n      \"value\": 22.5,\n      \"unit\": \"C\"\n    },\n    \"humidity\": {\n      \"value\": 60,\n      \"unit\": \"%\"\n    },\n    \"wind\": {\n      \"speed\": {\n        \"value\": 5.5,\n        \"unit\": \"m/s\"\n      },\n      \"direction\": \"NW\"\n    }\n  }\n})\";\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // Define the document size (use ArduinoJson Assistant to calculate)\n  JsonDocument doc;\n\n  // Parse the JSON string\n  DeserializationError error = deserializeJson(doc, weatherJson);\n\n  if (error) {\n    Serial.print(\"Failed to parse JSON: \");\n    Serial.println(error.f_str());\n    return;\n  }\n\n  // Access JSON data\n  const char* stationId = doc[\"station\"][\"id\"];\n  float latitude = doc[\"station\"][\"location\"][\"latitude\"];\n  float longitude = doc[\"station\"][\"location\"][\"longitude\"];\n  const char* timestamp = doc[\"timestamp\"];\n\n  float tempValue = doc[\"sensors\"][\"temperature\"][\"value\"];\n  const char* tempUnit = doc[\"sensors\"][\"temperature\"][\"unit\"];\n\n  int humidityValue = doc[\"sensors\"][\"humidity\"][\"value\"];\n  const char* humidityUnit = doc[\"sensors\"][\"humidity\"][\"unit\"];\n\n  float windSpeedValue = doc[\"sensors\"][\"wind\"][\"speed\"][\"value\"];\n  const char* windSpeedUnit = doc[\"sensors\"][\"wind\"][\"speed\"][\"unit\"];\n  const char* windDirection = doc[\"sensors\"][\"wind\"][\"direction\"];\n\n  // Print data to Serial Monitor\n  Serial.println(\"Weather Station Data:\");\n  Serial.printf(\"Station ID: %s\\n\", stationId);\n  Serial.printf(\"Location: %.4f, %.4f\\n\", latitude, longitude);\n  Serial.printf(\"Timestamp: %s\\n\", timestamp);\n  Serial.printf(\"Temperature: %.1f %s\\n\", tempValue, tempUnit);\n  Serial.printf(\"Humidity: %d %s\\n\", humidityValue, humidityUnit);\n  Serial.printf(\"Wind: %.1f %s, Direction: %s\\n\", windSpeedValue, windSpeedUnit, windDirection);\n}\n\nvoid loop() {\n  // Main loop (optional)\n}\n</code></pre>"},{"location":"Day2%20%3A%20Coding/ArduinoJson7/#creating-a-complex-json-with-arduinojson","title":"Creating a Complex JSON with ArduinoJson","text":"<pre><code>#include &lt;ArduinoJson.h&gt;\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // Define the document size\n  JsonDocument doc;\n\n  // Create JSON structure\n  JsonObject station = doc.createNestedObject(\"station\");\n  station[\"id\"] = \"WS1234\";\n\n  JsonObject location = station.createNestedObject(\"location\");\n  location[\"latitude\"] = 37.7749;\n  location[\"longitude\"] = -122.4194;\n\n  doc[\"timestamp\"] = \"2024-11-20T15:00:00Z\";\n\n  JsonObject sensors = doc.createNestedObject(\"sensors\");\n\n  JsonObject temperature = sensors.createNestedObject(\"temperature\");\n  temperature[\"value\"] = 22.5;\n  temperature[\"unit\"] = \"C\";\n\n  JsonObject humidity = sensors.createNestedObject(\"humidity\");\n  humidity[\"value\"] = 60;\n  humidity[\"unit\"] = \"%\";\n\n  JsonObject wind = sensors.createNestedObject(\"wind\");\n\n  JsonObject speed = wind.createNestedObject(\"speed\");\n  speed[\"value\"] = 5.5;\n  speed[\"unit\"] = \"m/s\";\n\n  wind[\"direction\"] = \"NW\";\n\n  // Serialize JSON to string\n  serializeJson(doc, Serial);\n}\n\nvoid loop() {\n  // Main loop (optional)\n}\n</code></pre>"},{"location":"Day2%20%3A%20Coding/ArduinoJson7/#output-example","title":"Output Example","text":"<p>The output JSON string will look like this:</p> <pre><code>{\"station\":{\"id\":\"WS1234\",\"location\":{\"latitude\":37.7749,\"longitude\":-122.4194}},\"timestamp\":\"2024-11-20T15:00:00Z\",\"sensors\":{\"temperature\":{\"value\":22.5,\"unit\":\"C\"},\"humidity\":{\"value\":60,\"unit\":\"%\"},\"wind\":{\"speed\":{\"value\":5.5,\"unit\":\"m/s\"},\"direction\":\"NW\"}}}\n</code></pre>"},{"location":"Day2%20%3A%20Coding/ArduinoJson7/#tips-for-complex-json","title":"Tips for Complex JSON","text":"<ol> <li>Pre-calculate memory size: Use the ArduinoJson Assistant to determine the optimal JsonDocument size.</li> <li>Nested Objects and Arrays: Use createNestedObject() or createNestedArray() for structured data.</li> <li>Error Handling: Always check DeserializationError for parsing issues.</li> </ol> <p>This approach enables you to handle detailed sensor data efficiently on microcontrollers like the ESP32.</p> <p></p> <p>next:</p> <p></p>"},{"location":"Day2%20%3A%20Coding/ArduinoJson7/#code-generate-from-online-application","title":"Code: Generate from online application","text":"<p>copy code:</p> code for test<pre><code>// Stream&amp; input;\n\nJsonDocument doc;\n\nDeserializationError error = deserializeJson(doc, input);\n\nif (error) {\n  Serial.print(\"deserializeJson() failed: \");\n  Serial.println(error.c_str());\n  return;\n}\n\nconst char* station_id = doc[\"station\"][\"id\"]; // \"WS1234\"\n\nfloat station_location_latitude = doc[\"station\"][\"location\"][\"latitude\"]; // 37.7749\ndouble station_location_longitude = doc[\"station\"][\"location\"][\"longitude\"]; // -122.4194\n\nconst char* timestamp = doc[\"timestamp\"]; // \"2024-11-20T15:00:00Z\"\n\nJsonObject sensors = doc[\"sensors\"];\n\nfloat sensors_temperature_value = sensors[\"temperature\"][\"value\"]; // 22.5\nconst char* sensors_temperature_unit = sensors[\"temperature\"][\"unit\"]; // \"C\"\n\nint sensors_humidity_value = sensors[\"humidity\"][\"value\"]; // 60\nconst char* sensors_humidity_unit = sensors[\"humidity\"][\"unit\"]; // \"%\"\n\nfloat sensors_wind_speed_value = sensors[\"wind\"][\"speed\"][\"value\"]; // 5.5\nconst char* sensors_wind_speed_unit = sensors[\"wind\"][\"speed\"][\"unit\"]; // \"m/s\"\n\nconst char* sensors_wind_direction = sensors[\"wind\"][\"direction\"]; // \"NW\"\n</code></pre>"},{"location":"Day2%20%3A%20Coding/ArduinoJson7/#f","title":"f( : )","text":"<p>The for loop with a colon, commonly referred to as a range-based for loop, is a feature in modern C++ (introduced in C++11). It simplifies iterating over a container, array, or range of elements.</p> <pre><code>for (element_declaration : container) {\n    // Loop body\n}\n</code></pre> <p>Example</p> <pre><code>#include &lt;ArduinoJson.h&gt;\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // JSON string\n  const char* json = R\"({\n    \"temperature\": 22.5,\n    \"humidity\": 60,\n    \"pressure\": 1013\n  })\";\n\n  // Parse the JSON\n  JsonDocument doc;\n  DeserializationError error = deserializeJson(doc, json);\n\n  if (error) {\n    Serial.print(\"Failed to parse JSON: \");\n    Serial.println(error.f_str());\n    return;\n  }\n\n  // Get the JsonObject\n  JsonObject obj = doc.as&lt;JsonObject&gt;();\n  //\n  if (obj.isNull()) {\n    Serial.println(\"The JSON data is not an object!\");\n  }\n  // Iterate over key-value pairs in the object\n  for (JsonPair kv : obj) {\n    const char* key = kv.key().c_str(); // Get the key\n    JsonVariant value = kv.value();    // Get the value\n\n    // Print the key and value\n    Serial.print(\"Key: \");\n    Serial.print(key);\n    Serial.print(\", Value: \");\n    Serial.println(value.as&lt;String&gt;()); // Convert value to String for printing\n  }\n}\n\nvoid loop() {\n  // Your loop code\n}\n</code></pre> <p>output:</p> <pre><code>Key: temperature, Value: 22.5\nKey: humidity, Value: 60\nKey: status, Value: OK\n</code></pre>"},{"location":"Day2%20%3A%20Coding/ArduinoJson7/#type-conversion-as","title":"Type conversion as() <p>In ArduinoJson, the as() function is used to cast a JsonDocument to a JsonObject when you know the JSON data is structured as an object. This allows you to access the key-value pairs stored in the object. <p>When to Use doc.as() <ol> <li>If your JSON data is an object (e.g., {\"key\": \"value\"}).</li> <li>When you want to access the individual keys and values.</li> </ol> <p>The as() is particularly useful when iterating over all the key-value pairs in an object. error checking<pre><code>    JsonObject obj = doc.as&lt;JsonObject&gt;();\n    if (obj.isNull()) {\n    Serial.println(\"The JSON data is not an object!\");\n    }\n</code></pre>","text":""},{"location":"Day2%20%3A%20Coding/cloneproject/","title":"Learn From Code","text":""},{"location":"Day2%20%3A%20Coding/cloneproject/#1-clone-example-code-from-github","title":"1 Clone example code from github","text":"<p>https://github.com/opendevbook/muict_fullstack_iot</p> clone repository<pre><code>git clone https://github.com/opendevbook/muict_fullstack_iot.git\n</code></pre>"},{"location":"Day2%20%3A%20Coding/platformio/","title":"Install platform io extenstion on Vscode","text":""},{"location":"Day2%20%3A%20Coding/platformio/#1-install-vscode-httpscodevisualstudiocom","title":"1 Install vscode https://code.visualstudio.com/","text":"<ol> <li>Open VSCode Extension Manager</li> <li>Search for official PlatformIO IDE extension</li> <li>Install PlatformIO IDE.</li> </ol>"},{"location":"Day2%20%3A%20Coding/platformio/#2-show-menu-buttom-bar","title":"2 Show menu buttom bar","text":""},{"location":"Day2%20%3A%20Coding/platformio/#3-create-platform-io-project","title":"3 Create Platform io project","text":"<ul> <li> <p>Project name : muict_platformio_esp32_1   </p> </li> <li> <p>add project info   </p> </li> <li> <p>Check menu   </p> </li> </ul>"},{"location":"Day2%20%3A%20Coding/sharedattribe/","title":"Share Attributes in Thingsboard","text":""},{"location":"Day2%20%3A%20Coding/sharedattribe/#summary-shared-attribute-topic-in-thingsboard","title":"Summary: Shared Attribute Topic in ThingsBoard","text":"<p>Objective of Shared Attributes:</p> <ol> <li>Remote Configuration: Configure devices remotely by sending key-value pairs from the server.</li> <li>State Synchronization: Synchronize device behavior with server-defined parameters.</li> <li>Device Customization: Dynamically adjust device operations based on server settings.</li> <li>Efficient Communication: Reduce over-the-air updates by enabling flexible, dynamic configurations.</li> </ol>"},{"location":"Day2%20%3A%20Coding/sharedattribe/#shared-attribute-mqtt-topics","title":"Shared Attribute MQTT Topics","text":""},{"location":"Day2%20%3A%20Coding/sharedattribe/#1-requesting-shared-attributes","title":"1 Requesting Shared Attributes:","text":"<ul> <li>Topic:</li> </ul> <pre><code>v1/devices/me/attributes/request/&lt;request_id&gt;\n</code></pre> <ul> <li>Payload Example (empty to fetch all shared attributes):</li> </ul> <pre><code>{}\n</code></pre>"},{"location":"Day2%20%3A%20Coding/sharedattribe/#2-receiving-responses","title":"2 Receiving Responses:","text":"<p>Topic:</p> <pre><code>v1/devices/me/attributes/response/&lt;request_id&gt;\n</code></pre> <pre><code>{\n  \"shared\": {\n    \"configMode\": \"auto\",\n    \"threshold\": 25\n  }\n}\n</code></pre>"},{"location":"Day2%20%3A%20Coding/sharedattribe/#how-it-works","title":"How It Works","text":"<ol> <li>Tenant defines shared attributes in ThingsBoard UI or via API.</li> <li>Device requests shared attributes using the request topic.</li> <li>Server responds with shared attributes on the response topic.</li> </ol>"},{"location":"Day2%20%3A%20Coding/sharedattribe/#key-use-cases","title":"Key Use Cases","text":"<ol> <li>Dynamic Threshold Updates: Devices fetch the latest threshold settings (e.g., for temperature).</li> <li>Device Behavior Control: Devices retrieve shared attributes to modify functionality (e.g., controlling relays).</li> <li>Periodic Configuration Fetching: Devices regularly fetch shared attributes to stay updated with current settings.</li> </ol> <p>Example mqttcode:</p> <pre><code>import paho.mqtt.client as mqtt\nimport json\n\n# MQTT settings\nbroker = \"thingsboard.cloud\"\nport = 1883\nclient_id = \"your-client-id\"\nusername = \"your-username\"\npassword = \"your-password\"\n\n# The topic with request ID (replace &lt;request_id&gt; with a unique value)\nrequest_id = \"1234567890\"\ntopic = f\"v1/devices/me/attributes/request/{request_id}\"\n\n# MQTT Client setup\nclient = mqtt.Client(client_id)\nclient.username_pw_set(username, password)\n\n# Connect to the ThingsBoard MQTT broker\nclient.connect(broker, port)\n\n# Payload to request all shared attributes (empty object)\npayload = {}\n\n# Publish the request\nclient.publish(topic, json.dumps(payload))\n\n# Loop forever to maintain connection and handle responses\nclient.loop_forever()\n</code></pre> <p></p>"},{"location":"Day2%20%3A%20Coding/thingsboard/","title":"Add thingsboard","text":"<p>Discuss Overvies </p>"},{"location":"Day2%20%3A%20Coding/thingsboard/#import-widget-bundle","title":"Import Widget Bundle","text":"<p>crate bundle </p> <p>add title of bundle: </p> <p>import widget into bundle</p> <p></p> <p>Browse file (in json format)</p> <p></p> <p>Select widget </p> <p>Import widget</p> <p></p> <p>Result import</p> <p></p>"},{"location":"Day2%20%3A%20Coding/thingsboard/#import-image-asset","title":"Import image Asset","text":"<p>Browse image</p> <p></p> <p>Select image</p> <p></p> <p>Click upload</p> <p></p> <p>Add more</p> <p></p>"},{"location":"Day2%20%3A%20Coding/thingsboard/#get-embeded-link","title":"Get Embeded link","text":"<p>Note</p> <p>/api/images/public/Os2MW3yQC7YHg1MwaRTthkRzokh0MGzt</p> <p>Add Widget to Dashboard</p> <p></p> <p>Select your Bundle</p> <p>Select entity_id and copy</p> <p></p> <p>Note</p> <p>0cc97a60-a03b-11ef-af67-a38a7671daf5</p> <p></p> <p>Select device widget</p> <p></p> <p>Selct device esp32</p> <p></p> <p>Add infomation</p> <p></p> <p>Save Dashboard </p>"}]}